# The Diary of WC++ Compiler




### 6.20
1. 词法分析部分：
    - 寻找C++关键字标准
    - 完善 l 和 y 文件
    - 数字和标识符的分析 在 词法分析中进行
    - 词法分析部分大致完毕 ✅

---

### 6.22
- 在词法分析 增加 识别float   
- 前期考虑将cout作为一个文法。例如 cout << a：在屏幕上打印变量a的值。
- 后期在考虑将cout作为一个函数。

#### 编译流程

源代码
↓ 词法分析（flex）✅ <ber>
↓ 语法分析+语义分析（yacc）✅<ber>
↓ 生成中间代码（三地址码）❌ <ber>
↓ 中间代码优化（可选）——————————————>先跳过，后期考虑 ❌ <ber>
↓ 寄存器分配 + 栈帧分配 ✅ <ber>
↓ 生成目标代码（x86汇编）——————————————>后期考虑生成RISC-V ✅<ber>
↓ 汇编 + 链接 ✅ <ber>
↓ 运行程序 ✅ <ber>
**目前任务：**先从C++产生式中挑出精简的部分。

---

### 6.25
- 后期再加 asm（""）❌
- 看 王挺 14.1.3
- 产生式写到：ptr-operator:star

---

### 思路

- 源代码
↓ 词法分析（flex）✅ <ber>
↓ 语法分析+语义分析（yacc）✅ <ber>
↓ 生成中间代码（LLVM IR ）❌ <ber>
↓ 中间代码优化（可选）——————————————>后期选择opt组件对LLVM IR进行优化 ❌ <ber>
↓ 寄存器分配 + 栈帧分配 ✅ <ber>
↓ 生成目标代码（x86汇编）——————————————>用LLC组件将LLVM IR转换成目标平台汇编代码，x86或者RISC-V ✅ <ber>
↓ 汇编 + 链接————————————————————>用clang 或者 gcc 链接 .s 文件，以生成机器代码 ✅ <ber>
↓ 运行程序 ✅ <ber>
---

### 6.27
- 王挺 14.1.3：继承属性的传递       实现例如 int a,b,c 的语义分析
- 修改了一些语法错误 ✅
- 接下来要实现 int a,b,c的语义分析，以及填写符号表 ✅

---

### 6.28
- 写initializer这些初始化变量的值  的产生式 ✅
- 进入了对 算数表达式 进行分析的产生式当中
- 写到了cast-expression ，对变量显式类型转换 ❌
- 明天接着写完cast-expression，然后理解赋值表达式的含义assignment-expression

---

### 6.29
- 变量的名字做成了token字：declarator_id
- 在词法分析中分析变量的名字（c++中分析变量的名字时在语法分析中进行的）
- 目前不考虑构造函数、析构函数。
- 把属性说明符序列全都删去了
- try{} catch(){}	语句先跳过

- 初步把expression 和 statement的产生式写完 ✅
- 之后先看懂expression的产生式，然后加上对应的语法动作

---

### 7.4
- 在看表达式的产生式
- 画出了各个表达式的对应关系（expression.drawio）✅
- 各个产生式的调用顺序  是按照运算符号的优先级高低。 ✅
- 后面考虑为表达式的产生式加上语义动作。

---

### 7.5
- 为表达式的文法 对应的非终结符赋予文法属性，
- 之后也要考虑进行错误处理， 比如不合法的表达式 ： int a； bool b；  int c; c = a + b; ✅
- expr_nonterminal的文法属性 已经用structure写出来了
- 明天写语义动作先从additive-expression开始写起。

---

### 7.6
- 没有考虑string类型，后期再加上 ❌
- additive-expression的语义动作写完了 
- 开始写init-declarator-list的语义动作，考虑先把定义变量和填写符号表实现，这样容易调试。
- 添加了指针类型（symbol_point） 指针字面量只有NULL。    这样避免用户写死地址。      当然int* a = &b这种写法是允许的。❌
- 后面要在additive-expression增加对于point类型的语义分析

---

### 7.13
- 一开始的想法：
    - 内部统一用 void* 代表“指针值”，不区分 int*、char* 
    - expression中的size属性是为了指针类型用的，比如int* a类型 ，size = 4； 这样就容易计算 a + （int）1； 
- 后面再加上：additive-expression增加对于point类型的语义分析
- 先填完符号表
- 把specifier冲突的问题用位图的方式解决了（可能有一些冲突的问题没考虑到）
- 对unsigned 和 signed这两个修饰符的处理还有问题. 下次考虑

---

### 7.15
- ./parser demo.c有问题
- 对unsigned 和 signed这两个修饰符的处理还有问题. 下次考虑

---

### 7.18
- ./parser demo.c的问题解决了：demo.c文件：int a;
- 问题是parser识别的token字是one_char 而不是identifier，导致了出错。
- 解决思路：token :one_char、identifier的name都传给了id- expression

---

### 7.19
- 检查定义的变量是否重复，简单的处理一下（后期还要修改一下，用于不同函数之间可以定义相同的变量名称）
- 需要处理int a = 1.234; float c = 4这些情况 

---

### 7.20
- 先不管short long unsigned signed如何处理。
- double x = 1 * 3 * 5.2;有问题。

---

符号表是静态分析工具，只会存储变量的初始值，之后变量的变化会体现在中间代码中，并不会修改符号表。

后面需要分析表达式如果是常量之间的计算，就直接常量折叠。如果是变量之间的计算，就需要生成中间代码。

```c
if ($1.constant && $3.constant) {
    $$.constant = true;
    $$.val = $1.val + $3.val;
} else {
    $$.constant = false;
    $$.addr = new_temp();
    gen(opr_add, $1.addr, $3.addr, $$.addr);
}
```

之后还需要学习一下LLVM表示

先学符号表知识和LLVM知识

将符号表分成了nametab 、 btab、atab

程序体结构：
	•	并列结构，如FORTRAN✅
	•	嵌套结构，如PASCAL、PL❌

继续听网课。

### 7.21
- 参数传递用传值的方法
- 存储分配策略使用：
- 静态分配策略（FORTRAN） ❌
- 动态分配策略 （允许递归和动态申请内存）✅
- 考虑用LLVM类库 来生成LLVM，而不是手写LLVM；
- 能不能自己手写LLVM，用类库太麻烦，而且不利于学习。
- 使用 Bison 的 %skeleton “lalr1.cc” 来启用 C++ 模式；
- 在语义动作中直接用 LLVM C++ API 生成中间代码；
- 整个工具链变成：Flex + Bison (C++) + LLVM IR。

---

### 7.22

- 不用生成LLVM中间代码了。
- 不生成中间语言了，直接生成x86代码，自己进行栈式管理和活动记录的管理。

源代码
  ↓ 词法分析（flex）
  ↓ 语法分析+语义分析（yacc）
  ↓ 生成目标代码（x86汇编）
  ↓ 汇编 + 链接————————————————————>用clang 或者 gcc 链接 .s 文件，以生成机器代码
  ↓ 运行程序

double x = 5.1 * 3;
x =  15.299999999999999.     正常现象，因为5.1本身在计算机中无法精确表示，是个近似值。

---

### 7.23

- 增加了Enter_btab函数，当一个函数分析结束之后，调用Enter_btab填btab表

---

### 7.24

- 完善了Enter_nametab和Enter_btab函数，
- nametab表的作用是记录var的名字、类型、在活动记录的偏移值
- btab表的作用是记录function的名字、类型、指向该函数体的形参在nametab的位置、局部变量在nametab的位置
- 以一字节（8bits）为基本单位

活动记录的布局是：
        |					|
        |					|
        |					|
        |	临时单元			|
        |	内情向量			|
        |	局部变量			|
        |	形式单元			|
        |	形参个数			|  4字节
        |	返回地址			|  4字节
sp——>	|	老SP			|  4字节

- 明天写parameter-declaration-list非终结符的语义分析，传递parameters的总大小，填入btab表中。

---

### 8.1

- 完善了语义分析中填写符号表的操作。
- Syntax错误，明天再说

---

### 8.2

- 解决了8.1的Syntax错误：
- bison这样会有问题：A: {} B C;     或者这样也有问题 A: B {} C;       //没太了解为啥
- 最终决定都用这样的语法动作。  A:B C {};
- 按函数功能调整了一下顺序。✅

---

### 8.5

- 填写btab ✅
- 完善命名冲突问题 ❌


---

### 8.6

- 完善命名冲突问题    ✅
- 增加了注释符号：//和/**/  ✅

---

### 8.10 & 8.11

- 完善了命名冲突问题。
- 开始statement的分析。
- 生成的汇编语言遵守 32 位 cdecl 调用约定
- 在写return时的gen code
- 分析函数时，序言的处理：1.进入 function-definition 时，清空一个 字符串缓冲区（存函数体的汇编）。2.	分析语句/表达式时，把汇编指令写入这个缓冲区（而不是直接输出到文件）。3.	分析完整个函数（拿到 vsize）后：先输出序言（用真实 locals 大小）。再把缓冲区里的函数体指令输出。最后输出尾声。 ✅
- 栈帧从高到低数，第二个4B（返回地址），第三个4B（par数量）还没有压入到栈中。
   例如：在output.asm中，mov  ebp, esp 和 sub  esp, 28 之间还要 push两个。

---